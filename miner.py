  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/dsp_url_20250819140833284B5521FA3143868FE411B113CA155A.jpg",
    "response": "这张广告图的排版布局**不合理**。\n\n理由如下：\n\n1.  **字与标签logo之间离得太近**：图中“赔付限额 600万元”这个标签（蓝色圆角矩形框）与上方的“责任范围内大病小病都能保”等宣传语文字在视觉上距离过近。宣传语文字位于图片上半部分，而标签位于图片下半部分，中间隔着一位女性模特。虽然模特是图像主体，但文字与标签之间没有足够的留白或视觉分隔，导致视觉上显得拥挤、层次不清，缺乏呼吸感。\n\n2.  **字与商品之间离得太近**：这里的“商品”指代的是图中女性模特所代表的“保险产品”或“保障服务”。宣传语文字（如“责任范围内大病小病都能保”）直接位于模特头部上方，而“赔付限额 600万元”标签位于模特身体下方。文字与模特形象（作为产品代言人）之间没有足够的空间缓冲，容易让观者感觉文字“贴”在模特身上，显得不够专业和疏离，也削弱了广告的视觉美感和信息层级。\n\n综上，由于存在“字与"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/dsp_url_2025082116555265CE45116D6D4CFEBB84379BDFF6E765.jpg",
    "response": "1. 字与标签logo之间：**没有离得太近**。  \n   图中“TASAKI”品牌文字位于图片底部中央，与上方的模特图像之间有明显的留白空间，视觉上分离清晰，符合广告设计中品牌标识与主体内容的常规布局，不会产生拥挤或压迫感。\n\n2. 字与商品之间：**没有离得太近**。  \n   “TASAKI”文字位于模特图像正下方，与模特佩戴的项链、耳环等商品之间隔着模特的肩部和服装，距离适中。这种布局是典型的“品牌标识置于产品下方”的广告排版，既突出商品，又保留品牌辨识度，不会造成视觉干扰。\n\n✅ **最终判断：这张广告图的排版布局合理。**\n\n理由：  \n- 品牌文字与图像内容（模特+商品）之间有充足留白，层次分明。  \n- 文字位置居中且处于视觉重心下方，符合广告视觉动线（从产品→品牌），不抢夺主体，也不显得孤立。  \n- 整体构图简洁、专业，符合高端珠宝品牌的调性。\n\n因此，该广告图排版布局合理，无明显"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/dsp_url_2025081511090977BACB55DB734F1EBD9D271FD20D246B.jpg",
    "response": "这张广告图的排版布局**不合理**。\n\n理由如下：\n\n1.  **字与标签logo之间离得太近**：图中“芒果tv”的logo位于抽油烟机下方，而“花儿与少年 同心季”的节目标题文字则叠加在人物胸前和锅具上方。这两个元素在视觉上距离非常近，几乎重叠在同一个垂直空间内。logo和文字（尤其是“花儿与少年”这几个大字）在构图上没有足够的留白或视觉分隔，显得拥挤，破坏了画面的层次感和专业感。\n\n2.  **字与商品之间离得太近**：节目标题文字“花儿与少年 同心季”直接覆盖在人物手中的盘子（商品/道具）和锅具之上，文字与商品（盘子、番茄、锅）有直接的重叠。这种设计不仅遮挡了商品的视觉呈现，也使文字与商品在视觉上“打架”，不符合广告图中“突出商品/场景”的常见排版原则。\n\n综上，由于**字与标签logo之间离得太近**，且**字与商品之间离得太近**，这两个问题同时存在，因此可以判定这张"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/20250820112913E9C27F4B1CB8491FBAA72D9B5C4E7644.jpg",
    "response": "1. **字与标签logo之间是否离得太近？**  \n   - 图中“支”字（支付宝的“支”）位于顶部，是品牌标识，下方是宣传语“动动手指上支付宝”。两者之间有明显的留白和视觉间距，符合广告设计中品牌标识与正文的常规布局，**不近**。\n\n2. **字与商品之间是否离得太近？**  \n   - 宣传语“动动手指上支付宝”和“天天必得20元外卖红包”位于画面中上部，而商品（炸鸡、薯条、鸡尾酒）位于画面中下部。两者之间有充足的视觉空间，文字没有压在商品上，也没有遮挡商品，**不近**。\n\n✅ **最终判断：这张广告图的排版布局合理。**\n\n理由：  \n- 品牌标识（“支”）与正文之间留白充足，符合视觉层级。  \n- 正文与商品之间有明确的视觉分隔，商品主体突出，文字不干扰商品展示。  \n- 整体布局层次清晰，符合广告设计的“品牌—信息—产品”三段式结构，引导用户视线从"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/dsp_url_20250625150356A2B11CA245CC4ACFB519ADF8442392D9.jpg",
    "response": "1. 字与标签logo之间距离：广告左上角的“热门短剧”标签logo与上方的“热播短剧”标签之间有明显间距，且与下方主文案“看短剧上河马剧场 好剧刷不停”也有合理留白，视觉上不拥挤。\n\n2. 字与商品之间距离：主文案“看短剧上河马剧场 好剧刷不停”位于画面中央偏上，下方是电影胶卷、胶片和拍板等“商品”（视觉元素），二者之间有清晰的视觉分隔和空间过渡，未出现文字覆盖或挤压商品元素的情况。\n\n结论：两张广告图的排版布局都合理，没有出现文字与标签logo或文字与商品之间离得太近的问题。因此，这张广告图的排版布局是合理的。\n\n✅ 最终判断：排版布局合理。"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/_202508201510250F0DEC26EEB9410B9D5901F1643273B2.jpg",
    "response": "这张广告图的排版布局**不合理**。\n\n理由如下：\n\n1.  **字与标签logo之间是否离得太近？**  \n    图中没有出现任何“标签logo”。广告图中仅有文字内容，没有品牌标识或Logo。因此，这个问题不适用，不存在“离得太近”的情况。\n\n2.  **字与商品之间是否离得太近？**  \n    图中没有明确的商品实物（如药品、保险产品实物等）。广告图展示的是一个办公场景（电脑、椅子、窗户等），这些是背景或场景元素，而非“商品”。广告的核心信息是文字内容（“责任内原研药可报销”等），这些文字是叠加在背景图片上的。从视觉上看，文字与背景中的办公桌、椅子等“场景元素”之间没有明显的“离得太近”或“重叠遮挡”的问题，但“商品”在图中并不存在。\n\n**然而，关键问题在于：**\n\n广告图的排版布局**不合理**，主要原因是：\n\n*   **文字与背景图像的融合度低，视觉焦点混乱。**  \n    大量白色文字直接叠加在暖色调的办公场景上，虽然文字清晰，但缺乏"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/dsp_url_2025050910345170230B855F5E4104BAC156A81E7C4FD1.jpg",
    "response": "1. **字与标签logo之间是否离得太近？**  \n   —— **否**。  \n   图中“基础版 百万医疗保险”中的“基础版”标签与“百万医疗保险”文字之间有清晰的间距，标签圆角矩形与文字之间留有适当呼吸空间，视觉上不拥挤，符合常规设计规范。\n\n2. **字与商品之间是否离得太近？**  \n   —— **是**。  \n   “基础版 百万医疗保险”这一标题文字位于画面下方蓝色区域，其下方紧跟着小字的保险条款说明（如“免赔额5万元及以内...”等），文字与商品（即“百万医疗保险”这一产品）之间几乎没有留白缓冲。这种“标题—说明”堆叠式排版，使得产品名称与细则文字在视觉上“挤在一起”，缺乏层次感和呼吸感，容易让读者产生压迫感，不符合现代广告设计中“信息分层、重点突出”的原则。\n\n**最终判断：这张广告图的排版布局不合理。**\n\n**理由：**  \n虽然标签与文字间距合理，但“产品名称”与“详细条款”之间的间距过小，造成信息层级"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/dsp_url_2025111916083498DF6C96FE1F49ADAB5BC03A2CC3C582.jpg",
    "response": "这张广告图的排版布局**合理**。\n\n理由如下：\n\n1.  **字与标签logo之间距离**：图中左上角的蓝色“支”字（支付宝logo的一部分）与下方的“上支付宝”文字之间有明显的留白和视觉间距，没有出现重叠或挤压的情况。这个距离符合视觉设计规范，既突出了品牌标识，又保证了文字信息的可读性。\n\n2.  **字与商品之间距离**：广告中的文字（“上支付宝”、“边看视频边领红包”、“有机会领4.88元”）主要集中在画面的上半部分，而“商品”（即图中人物正在观看的手机屏幕内容）是隐含的、非实体的“视频内容”。文字与“商品”之间没有物理上的距离问题，因为“商品”并非实体物品，而是用户观看的虚拟内容。从排版角度看，文字信息与用户行为（看手机）是紧密关联的，且文字位置在视觉上引导用户注意力向下看手机，布局是协调的。\n\n3.  **整体布局合理性**：\n    -   **视觉焦点清晰**：文字信息集中在顶部，形成视觉引导，人物和"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/_20250818102728e0ba23aa8458464ab443e37a611ad4c2.jpg",
    "response": "1. **字与标签logo之间是否离得太近？**  \n   → **否**。  \n   广告顶部的“dji | 百亿补贴”标签与下方的宣传语“横扫长空 势不可挡”之间有明显的间距，视觉上留白充足，不会显得拥挤。标签和文字之间没有重叠或挤压感，排版清晰。\n\n2. **字与商品之间是否离得太近？**  \n   → **是**。  \n   广告中的促销文字“补贴直降780元”位于无人机图像的正上方，且文字框与无人机的机臂/机身部分非常接近，视觉上存在“压着”商品的错觉。这种布局容易让观者误以为文字是直接“贴”在无人机上的，破坏了商品主体的视觉独立性，也影响了整体构图的呼吸感。\n\n3. **最终判断：这张广告图的排版布局是否合理？**  \n   → **不合理**。  \n   尽管顶部标签与宣传语排布合理，但促销文字与商品（无人机）之间距离过近，属于典型的“文字压商品”排版错误。这会削弱商品"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/_dsp_url_2025081914120668CC8FE7DABF46F68F564C6D1D0E4898.jpg",
    "response": "这张广告图的排版布局是**合理的**。\n\n理由如下：\n\n1.  **字与标签logo之间是否离得太近？**\n    -   图中没有出现“标签logo”（如品牌标志、商标等）。文字信息（如“保额600万元”、“免赔额5万元及以内...”等）位于图片下方的棕色渐变背景区域，而该区域本身就是一个设计好的信息展示区，不属于“标签logo”。\n    -   因此，不存在“字与标签logo之间离得太近”的问题。\n\n2.  **字与商品之间是否离得太近？**\n    -   图中没有明确展示“商品”（如实物产品、服务图标等）。图片中的“商品”是抽象的保险产品，其核心信息（保额、免赔额、赔付比例等）是通过文字形式直接传达的。\n    -   文字信息与“商品”（即保险产品）之间没有物理上的距离问题，因为文字本身就是对“商品”属性的描述。在广告设计中，这是非常常见的做法：用文字直接说明产品的核心卖点。\n    -   从视觉上看，文字区域与上方的模特图片之间"
  },
  {
    "image": "/home/wsw/gyx/code_11.28/test_data/正常-normal_data/_dsp_url_20250818150052614815232031446DB1C144BEBD86A58F.jpg",
    "response": "1. **字与标签logo之间是否离得太近？**  \n   - **判断：离得较近，但不算严重违规。**  \n     “蚂蚁保”标签logo位于图片左上角，下方是广告文字区域的起始位置。两者间距约1-2cm，视觉上属于紧凑但可接受的布局，未造成视觉冲突或压迫感，符合现代广告设计中“品牌露出+内容引导”的常见排版逻辑。\n\n2. **字与商品之间是否离得太近？**  \n   - **判断：离得较近，存在排版不合理风险。**  \n     广告文字（保障范围、保额、保费等）位于图片下方的棕色区域，而“商品”（即模特穿着的服装和手提包）位于图片上半部分。文字区域与模特主体（商品）之间隔着一个“半圆形过渡区”，但该区域视觉上较窄，且文字块直接压在模特腿部和沙发边缘的视觉空间上，容易让观众误以为文字是“贴在商品上”的，造成视觉重心混乱，削弱了商品的独立展示效果。这种布局在视觉传达上不够清晰，属于排版不合理。\n\n**"
  }
]
https://www.paddlepaddle.org.cn/packages/stable/cu126/
import io
import asyncio
import aiofiles
from vllm.v1.engine.async_llm import AsyncLLM
from vllm.engine.arg_utils import AsyncEngineArgs
from PIL import Image
from mineru_vl_utils import MinerUClient, MinerULogitsProcessor
import os
import cv2
import numpy as np
import json

# 设置GPU设备
os.environ['CUDA_VISIBLE_DEVICES'] = '7'

class MinerUProcessor:
    def __init__(self, model_path="opendatalab/MinerU2.5-2509-1.2B"):
        """初始化MinerU处理器"""
        self.model_path = model_path
        self.async_llm = None
        self.client = None
        
    async def initialize(self):
        """初始化AsyncLLM和MinerUClient"""
        print("正在初始化AsyncLLM...")
        # 创建async_llm
        self.async_llm = AsyncLLM.from_engine_args(
            AsyncEngineArgs(
                model=self.model_path,
                logits_processors=[MinerULogitsProcessor]
            )
        )
        
        print("正在初始化MinerUClient...")
        # 创建client
        self.client = MinerUClient(
            backend="vllm-async-engine",
            vllm_async_llm=self.async_llm,
        )
        print("初始化完成!")
        
    async def load_image(self, image_path):
        """异步加载图片，返回 PIL Image 和 OpenCV 格式"""
        print(f"正在加载图片: {image_path}")
        async with aiofiles.open(image_path, "rb") as f:
            image_data = await f.read()
        
        # 使用BytesIO创建PIL Image
        pil_image = Image.open(io.BytesIO(image_data))
        
        # 转换为 OpenCV 格式 (BGR)
        cv_image = cv2.imread(image_path)  # 直接使用 OpenCV 读取
        
        if cv_image is None:
            # 如果 OpenCV 读取失败，从 PIL 转换
            cv_image = cv2.cvtColor(np.array(pil_image), cv2.COLOR_RGB2BGR)
        
        print(f"图片加载完成，PIL尺寸: {pil_image.size}, OpenCV形状: {cv_image.shape}")
        return pil_image, cv_image
    
    async def extract_blocks(self, image_path):
        """完整的提取流程：加载图片 -> 提取块"""
        try:
            # 1. 确保已初始化
            if self.client is None:
                await self.initialize()
            
            # 2. 加载图片
            pil_image, cv_image = await self.load_image(image_path)
            
            # 3. 提取块
            print("正在提取块...")
            extracted_blocks = await self.client.aio_two_step_extract(pil_image)
            
            print("提取完成!")
            return extracted_blocks, cv_image
            
        except Exception as e:
            print(f"提取过程中出现错误: {e}")
            raise
    
    async def process_multiple_images(self, image_paths):
        """处理多张图片"""
        results = {}
        
        # 先初始化模型
        await self.initialize()
        
        for image_path in image_paths:
            try:
                print(f"\n{'='*50}")
                print(f"处理图片: {image_path}")
                
                # 加载图片
                pil_image, cv_image = await self.load_image(image_path)
                
                # 提取块
                extracted_blocks = await self.client.aio_two_step_extract(pil_image)
                
                # 调试：打印提取结果
                print(f"提取到 {len(extracted_blocks)} 个模块")
                
                # if len(extracted_blocks) > 0:
                #     print("\n模块详细信息:")
                #     for i, block in enumerate(extracted_blocks):
                #         print(f"模块 {i}:")
                #         print(f"  BBox: {block.bbox}")
                #         print(f"  类型: {block.type}")
                #         # print(f"  内容: {block.content[:50]}...")  # 只显示前50个字符
                
                results[image_path] = extracted_blocks
                
                # 在图像上绘制边界框
                img_with_boxes = cv_image.copy()
                
                if len(extracted_blocks) > 0:
                    print("\n正在绘制边界框...")
                    for i, block in enumerate(extracted_blocks):
                        try:
                            # 获取边界框坐标
                            bbox = block.bbox
                            print(f"  模块 {i} 原始bbox: {bbox}")
                            
                            # 确保 bbox 是 [x_min, y_min, x_max, y_max] 格式
                            if len(bbox) == 4:
                                x_min, y_min, x_max, y_max = bbox
                                
# 确保坐标在合理范围内
height, width = img_with_boxes.shape[:2]

# --- 修改开始 ---
# 判断是否为归一化坐标 (假设如果坐标都小于等于1，则是归一化坐标)
if all(x <= 1.0 for x in [x_min, y_min, x_max, y_max]):
    print(f"  检测到归一化坐标，正在转换...")
    x_min = int(x_min * width)
    x_max = int(x_max * width)
    y_min = int(y_min * height)
    y_max = int(y_max * height)
else:
    # 已经是像素坐标，直接取整
    x_min = int(x_min)
    y_min = int(y_min)
    x_max = int(x_max)
    y_max = int(y_max)

# 限制坐标在图像范围内 (防止越界)
x_min = max(0, min(x_min, width - 1))
y_min = max(0, min(y_min, height - 1))
x_max = max(0, min(x_max, width - 1))
y_max = max(0, min(y_max, height - 1))
# --- 修改结束 ---

print(f"  模块 {i} 修正后bbox: [{x_min}, {y_min}, {x_max}, {y_max}]")
                                
                                # 绘制边界框
                                color = (0, 255, 0)  # 绿色 (BGR格式)
                                thickness = 2
                                cv2.rectangle(img_with_boxes, 
                                            (x_min, y_min), 
                                            (x_max, y_max), 
                                            color, thickness)
                                
                                # 添加模块编号标签
                                label = f"Module {i}"
                                font = cv2.FONT_HERSHEY_SIMPLEX
                                font_scale = 0.5
                                label_thickness = 2
                                
                                # 计算文本大小
                                (text_width, text_height), baseline = cv2.getTextSize(
                                    label, font, font_scale, label_thickness
                                )
                                
                                # 绘制文本背景
                                cv2.rectangle(img_with_boxes,
                                            (x_min, y_min - text_height - 10),
                                            (x_min + text_width, y_min),
                                            color, -1)  # -1 表示填充
                                
                                # 绘制文本
                                cv2.putText(img_with_boxes, label,
                                          (x_min, y_min - 5),
                                          font, font_scale,
                                          (0, 0, 0),  # 黑色文本
                                          label_thickness)
                                
                                print(f"  模块 {i} 边界框已绘制")
                            else:
                                print(f"  模块 {i} 的bbox格式不正确: {bbox}")
                                
                        except Exception as e:
                            print(f"  绘制模块 {i} 时出错: {e}")
                            continue
                else:
                    print("警告: 未提取到任何模块!")
                    # 在没有模块时，添加一个提示文本
                    cv2.putText(img_with_boxes, "No modules detected",
                              (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1,
                              (0, 0, 255), 2)
                
                # 保存带框图像
                output_dir = "/home/wsw/gyx/code_12.17/layout_paibu"
                os.makedirs(output_dir, exist_ok=True)
                
                # 生成输出文件名
                base_name = os.path.basename(image_path)
                name_without_ext = os.path.splitext(base_name)[0]
                output_path = os.path.join(output_dir, f"{name_without_ext}_annotated.jpg")
                
                # 保存图像
                cv2.imwrite(output_path, img_with_boxes)
                print(f"保存带框图像到: {output_path}")
                
                # 同时保存JSON结果
                json_path = os.path.join(output_dir, f"{name_without_ext}_results.json")
                json_results = []
                for block in extracted_blocks:
                    json_results.append({
                        "bbox": block.bbox,
                        "type": block.type,
                        "content": block.content[:500]  # 限制内容长度
                    })
                
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(json_results, f, ensure_ascii=False, indent=2)
                print(f"保存结果到: {json_path}")
                
                print(f"图片 {image_path} 处理完成")
                
            except Exception as e:
                print(f"处理图片 {image_path} 时出错: {e}")
                import traceback
                traceback.print_exc()
                results[image_path] = None
        
        return results
    
    async def shutdown(self):
        """关闭资源"""
        if self.async_llm is not None:
            print("正在关闭AsyncLLM...")
            self.async_llm.shutdown()
            print("资源已释放")

def test_single_image():
    """测试单张图片的边界框绘制"""
    test_image_path = "/home/wsw/gyx/code_11.28/test_data/排布间距/20241212112442EECEB9747D62434FBDC1F1CA71BE7829 (1).jpg"
    
    # 简单测试：先不用异步，直接检查图像
    print("测试单张图片...")
    
    # 读取图像
    cv_image = cv2.imread(test_image_path)
    if cv_image is None:
        print("错误: 无法读取图像")
        return
    
    print(f"图像尺寸: {cv_image.shape}")
    
    # 手动添加一个测试边界框（确认OpenCV工作正常）
    height, width = cv_image.shape[:2]
    test_box = [100, 100, 300, 200]  # [x_min, y_min, x_max, y_max]
    
    # 绘制测试框
    x_min, y_min, x_max, y_max = test_box
    cv2.rectangle(cv_image, (x_min, y_min), (x_max, y_max), (0, 0, 255), 3)  # 红色框
    
    # 保存测试图像
    test_output = "/home/wsw/gyx/code_12.17/layout_paibu/test_box.jpg"
    cv2.imwrite(test_output, cv_image)
    print(f"测试图像已保存到: {test_output}")
    print("请检查这个测试图像是否包含红色边界框")
    
    # 如果测试图像正常，说明OpenCV工作正常
    # 问题可能在提取的blocks为空或坐标格式不对

async def debug_extraction(image_path):
    """调试提取过程"""
    processor = MinerUProcessor(model_path="opendatalab/MinerU2.5-2509-1.2B")
    
    try:
        await processor.initialize()
        
        # 加载图片
        pil_image, cv_image = await processor.load_image(image_path)
        
        # 提取块
        print("正在提取块...")
        extracted_blocks = await processor.client.aio_two_step_extract(pil_image)
        
        print(f"\n提取结果分析:")
        print(f"提取到 {len(extracted_blocks)} 个模块")
        
        if len(extracted_blocks) == 0:
            print("警告: 没有提取到任何模块!")
            print("可能原因:")
            print("1. 图像中没有可识别的模块")
            print("2. 模型参数可能需要调整")
            print("3. 图像质量或格式问题")
        else:
            # 详细打印每个模块的信息
            for i, block in enumerate(extracted_blocks):
                print(f"\n模块 {i}:")
                print(f"  BBox: {block.bbox}")
                print(f"  Type: {block.type}")
                # print(f"  Content (前100字符): {block.content[:100]}")
                
                # 检查BBox格式
                if hasattr(block.bbox, '__len__'):
                    print(f"  BBox长度: {len(block.bbox)}")
                    if len(block.bbox) >= 4:
                        x_min, y_min, x_max, y_max = block.bbox[:4]
                        print(f"  坐标范围: x=[{x_min}, {x_max}], y=[{y_min}, {y_max}]")
                        
                        # 检查坐标是否合理
                        height, width = cv_image.shape[:2]
                        if x_min < 0 or y_min < 0 or x_max > width or y_max > height:
                            print(f"  警告: 坐标超出图像范围!")
                        if x_min >= x_max or y_min >= y_max:
                            print(f"  警告: 坐标值无效 (x_min >= x_max 或 y_min >= y_max)!")
        
        return extracted_blocks
        
    finally:
        await processor.shutdown()

async def main_batch(image_paths):
    """批量处理图片的示例"""
    processor = MinerUProcessor(model_path="opendatalab/MinerU2.5-2509-1.2B")
    
    try:
        print("批量处理图片...")
        results = await processor.process_multiple_images(image_paths)
        
        print("\n" + "="*50)
        print("处理结果汇总:")
        for path, blocks in results.items():
            print(f"\n图片: {path}")
            print(f"提取到 {len(blocks) if blocks else 0} 个模块")
            
    finally:
        await processor.shutdown()

if __name__ == "__main__":
    # # 第一步：测试OpenCV是否能正常绘制边界框
    # print("第一步：测试OpenCV功能...")
    # test_single_image()
    
    # # 第二步：调试提取过程
    # print("\n" + "="*50)
    # print("第二步：调试提取过程...")
    # test_image = "/home/wsw/gyx/code_11.28/test_data/排布间距/20241212112442EECEB9747D62434FBDC1F1CA71BE7829 (1).jpg"
    # asyncio.run(debug_extraction(test_image))
    
    # 第三步：批量处理
    print("\n" + "="*50)
    print("第三步：批量处理所有图片...")
    
    folders = ["/home/wsw/gyx/code_11.28/test_data/排布间距"]
    image_files = []
    
    for folder in folders:
        for root, _, files in os.walk(folder):
            for file in files:
                if file.lower().endswith(('.png', '.jpg', '.jpeg')):  # 只处理图像文件
                    image_files.append(os.path.join(root, file))
    
    print(f"找到 {len(image_files)} 张图片")
    
    # 先处理几张测试
    if len(image_files) > 0:
        # 先处理前3张看看效果
        test_files = image_files[:3]
        print(f"先处理前 {len(test_files)} 张图片作为测试...")
        asyncio.run(main_batch(test_files))
    else:
        print("没有找到图片文件!")

模块 3 原始bbox: [0.301, 0.346, 0.686, 0.389]
  模块 3 修正后bbox: [0, 0, 0, 0]
